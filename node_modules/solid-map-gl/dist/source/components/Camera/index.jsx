import { createEffect, onCleanup, createSignal } from 'solid-js';
import { useMapContext } from '../MapProvider';
// linearly interpolate between two positions [x,y,z] based on time
const lerp = (a, b, t) => a.map((_, idx) => (1.0 - t) * a[idx] + t * b[idx]);
// sphericaly interpolate between two positions [x,y,z] based on time
const slerp = (a, b, t) => {
    const dotProduct = a.map((_, idx) => a[idx] * b[idx]).reduce((m, n) => m + n);
    const theta = Math.acos(dotProduct);
    return a.map((_, idx) => (Math.sin((1 - t) * theta) / Math.sin(theta)) * a[idx] +
        (Math.sin(t * theta) / Math.sin(theta)) * b[idx]);
};
// calculations from: https://easings.net
const easeQuad = {
    in: (x) => x * x,
    out: (x) => 1 - (1 - x) * (1 - x),
    inOut: (x) => x < 0.5 ? 2 * x * x : 1 - Math.pow(-2 * x + 2, 2) / 2,
};
export const Camera = (props) => {
    const [ctx] = useMapContext();
    let animationTime = 0.1;
    let isReverse = false;
    // Handle User Interaction
    const [userInteraction, setUserInteraction] = createSignal(false);
    ['mousedown', 'touchstart', 'wheel'].forEach((event) => ctx.map.on(event, (evt) => !evt.rotate && setUserInteraction(true)));
    ['moveend', 'mouseup', 'touchend'].forEach((event) => ctx.map.on(event, (evt) => !evt.rotate && setUserInteraction(false)));
    const updateCameraPosition = async ([lng, lat, alt], target) => {
        const camera = ctx.map.getFreeCameraOptions();
        camera.position = window.MapLib.MercatorCoordinate.fromLngLat([lng, lat], alt);
        camera.lookAtPoint(target);
        ctx.map.setFreeCameraOptions(camera);
    };
    const frame = () => {
        props.translate && window.requestAnimationFrame(frame);
        const params = [
            props.translate.start,
            props.translate.end,
            props.translate.easing
                ? easeQuad[props.translate.easing](animationTime)
                : animationTime,
        ];
        const position = props.translate.type === 'line' ? lerp(...params) : slerp(...params);
        updateCameraPosition(position, props.translate.target);
        if (!props.translate.loop && (animationTime > 1.0 || animationTime < 0.0))
            isReverse = !isReverse;
        animationTime = isReverse ? animationTime - 0.001 : animationTime + 0.001;
    };
    createEffect(() => {
        props.translate && window.requestAnimationFrame(frame);
    });
    const options = { duration: 1000, easing: (n) => n };
    const rotateGlobe = () => {
        if (userInteraction())
            return;
        const { secPerRev = 120, maxSpinZoom = 5, slowSpinZoom = 3, } = props.rotateGlobe;
        const zoom = ctx.map.getZoom();
        if (zoom > maxSpinZoom)
            return;
        let distancePerSecond = 360 / secPerRev;
        if (zoom > slowSpinZoom)
            distancePerSecond *= (maxSpinZoom - zoom) / (maxSpinZoom - slowSpinZoom);
        const center = ctx.map.getCenter();
        center.lng = props.reverse
            ? center.lng + distancePerSecond
            : center.lng - distancePerSecond;
        ctx.map.easeTo({ center, ...options }, { rotate: true });
    };
    const rotateViewport = () => {
        if (!props.rotateViewport || userInteraction()) {
            ctx.map.stop();
            return;
        }
        const rotateViewport = props.rotateViewport;
        const secPerRev = rotateViewport?.secPerRev || 60;
        const bearing = props.reverse
            ? ctx.map.getBearing() + 360 / secPerRev
            : ctx.map.getBearing() - 360 / secPerRev;
        const pitch = rotateViewport?.pitch || 60;
        const around = rotateViewport?.around;
        ctx.map.easeTo({ bearing, pitch, around, ...options }, { rotate: true });
    };
    const onEnd = () => (props.rotateGlobe ? rotateGlobe() : rotateViewport());
    ctx.map.on('moveend', onEnd).on('dragend', onEnd);
    let originalCenter;
    createEffect(() => {
        if (props.rotateGlobe == undefined)
            return;
        if (props.rotateGlobe) {
            originalCenter = ctx.map.getCenter();
            rotateGlobe();
        }
        else {
            props.resetWhenStopped
                ? ctx.map.stop().easeTo({ center: originalCenter })
                : ctx.map.stop();
        }
    });
    createEffect(() => {
        if (props.rotateViewport == undefined)
            return;
        props.rotateViewport
            ? rotateViewport()
            : props.resetWhenStopped
                ? ctx.map.stop().resetNorthPitch()
                : ctx.map.stop();
    });
    onCleanup(() => ctx.map.off('moveend', onEnd).off('dragend', onEnd));
    return props.children;
};
